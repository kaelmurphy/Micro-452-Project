# Position estimation
var um = 0
var p_um = 0
var p_mm = 0

# Position error
var e_um = 0
var e_mm = 0

# (Anti-)Symetric speed variable
var speed = 0

# Update loop
var done = 0
onevent motor

	# Early return if done
	if done == 1 then
		return
	end

	# Update position estimate
	call math.muldiv(um, abs motor.left.speed + abs motor.right.speed, 15372, 10000)
	p_um += um
	p_mm += p_um / 1000
	p_um %= 1000

	# Compute position error
  	e_mm = {TARGET} - p_mm
	if p_um == 0 then
		e_um = 0
	else
		e_mm--
		e_um = 1000 - p_um
	end

	# Stop if within tolerance
	if e_mm < 0 or (e_mm == 0 and e_um <= 100) then
		motor.left.target = 0
		motor.right.target = 0
		done = 1
		timer.period[0] = 2000
		emit done
		return
	end

	# Compute speed with smooth stop
	if e_mm >= 20 then
		speed = 500
	else
		speed = (1 + e_mm) * 25
	end
  	
  	# Apply target speed
	motor.left.target = {LEFT_SIGN}speed
	motor.right.target = {RIGHT_SIGN}speed

# Resend event if missed by the application
onevent timer0

	# Early return if done
	if done == 1 then
		emit done
	end
